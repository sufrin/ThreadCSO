\@doanenote {1}
macro:->This
was
derived
from
an
earlier
library,
written
in
Generic
Java,
whose
development
had
been
inspired
by
the
appearance
of
the
first
public
edition
of
JCSP.
The
principal
differences
between
that
library
and
the
JCSP
library
were
the
generically
parameterized
interfaces,
\textsf
{InPort}
and
\textsf
{OutPort}
akin
to
what
JCSP
called
``channel
ends.''
\@endanenote 
\@doanenote {2}
macro:->Although
Scala
interoperates
with
Java,
and
we
could
easily
have
constructed
Scala
``wrappers''
for
the
JCSP
library
and
for
our
own
derivative
library,
we
wanted
to
have
a
pure
Scala
implementation
both
to
use
as
part
of
our
instructional
material,
and
to
ensure
portability
to
the
\textsf
{.NET}
platform
when
the
Scala
\textsf
{.NET}
compiler
became
available.
\@endanenote 
\@doanenote {3}
macro:->The
(admirably
ingenious)
Actor
library
implementation
is
complicated;
its
performance
appears
to
scale
well
only
for
certain
styles
of
use;
and
it
depends
for
correct
functioning
on
a
global
timestamp
(\cite
{actors2}
p183).
\@endanenote 
\@doanenote {4}
macro:->The
present
pool
implementation
acquires
new
worker
threads
from
the
underlying
JVM
when
necessary
and
``retires''
threads
that
have
remained
dormant
in
the
pool
for
more
than
a
certain
period.
\@endanenote 
\@doanenote {5}
macro:->The
expression
$\mathsf
{run}(p)$
has
exactly
the
same
effect
as
$p()$.
The
expression
$\mathsf
{fork}(p)$
runs
$p$
in
a
new
thread
concurrent
with
the
thread
that
invoked
\textsf
{fork},
and
returns
a
\textit
{handle}
on
the
running
process.
The
new
thread
is
recycled
when
the
process
terminates.
\@endanenote 
\@doanenote {6}
macro:->This
is
because
\textsc
{io.threadcso.process.Stopped}
exceptions
signify
anticipated
failure,
whereas
other
types
of
exception
signify
unexpected
failure,
and
must
be
propagated
rather
than
silently
ignored.
One
useful
consequence
of
the
special
treatment
of
\textsc
{io.threadcso.process.Stopped}
exceptions
is
explained
in
section
\ref
{Closing
Ports
and
Channels}:
\textit
{Closing
Ports
and
Channels}.
\@endanenote 
\@doanenote {7}
macro:->Other
forms
of
synchronous
channel,
mostly
now
obsolete,
are:
\begin
{itemize}
\par
\par
\item
\textscala
{ManyOne[T]}
--
No
more
than
one
process
at
a
time
may
access
its
input
port;
processes
attempting
to
access
its
output
port
get
access
in
nondeterministic
order.
{The
name
is
a
contraction
of
``From
\textsc
{Many}
possible
writer
processes
to
\textsc
{One}
reader
process.''
The
other
forms
of
synchronous
channel
are
named
using
the
same
contraction
convention.}
\par
\item
\textscala
{OneMany[T]}
--
No
more
than
one
process
at
a
time
may
access
its
output
port;
processes
attempting
to
access
its
input
port
get
access
in
nondeterministic
order.
\par
\item
\textscala
{ManyMany[T]}
--
Any
number
of
processes
may
attempt
to
access
either
port.
Writing
processes
get
access
in
nondeterministic
order,
as
do
reading
processes.
\par
\end
{itemize}

\@endanenote 
\@doanenote {8}
macro:->The
name
is
a
contraction
of
``From
\textsc
{One}
writer
process
to
\textsc
{One}
reader
process.''
\@endanenote 
\@doanenote {9}
macro:->See,
for
example,
the
component
\textsc
{mux2}
defined
in
\Listing
\ref
{mux}.
\@endanenote 
\@doanenote {10}
macro:->The
reduction
of
formal
clutter
comes
at
the
cost
of
forcing
readers
to
refer
back
to
the
component
signatures
to
ascertain
which
ports
they
actually
use.
The
JCSP
designers
made
the
tradeoff
in
the
other
direction.
\@endanenote 
\@doanenote {11}
macro:->We
have
used
the
plain
form
of
read
$(mid?())$
and
its
read-and-evaluate
form
$(ins(i)
?
{
v
\Rightarrow
mid!(i,
v)})$
simply
to
give
an
example
of
the
latter.
\@endanenote 
\@doanenote {12}
macro:->The
most
general
form
of
extended
rendezvous
read
is
\textsc
{in??f}
where
\textsc
{f}
denotes
a
function
of
type
\textsc
{T=>U}.
The
type
of
\textsc
{in??f}
is
then
\textsc
{U}.
\@endanenote 
\@doanenote {13}
macro:->This
is
a
deliberate
choice,
designed
to
keep
shared
channel
semantics
simple.
More
complex
channel-like
abstractions
--
such
as
one
in
which
a
non-shared
end
is
informed
when
all
subscribers
to
the
shared
end
have
disappeared
--
can
always
be
layered
on
top
of
it.
\@endanenote 
\@doanenote {14}
macro:->\textit
{i.e.}
from
the
\textsc
{out}
direction.
On
the
face
of
it
it
looks
like
this
could
be
avoided
by
reprogramming
the
component
with
a
stronger
guard
to
the
iteration,
\textit
{viz}
as:
\textsc
{repeat
(out.canOutput)
\{
out!(in?())
\}}
\textit
{but
this
is
not
so},
because
the
\textsc
{out.canOutput}
test
and
the
\textsc
{out!}
action
are
not
joined
atomically,
so
the
channel
associated
with
the
output
port
could
be
closed
between
being
polled
in
the
guard
and
being
written
to
in
the
body
of
the
loop.
\@endanenote 
\@doanenote {15}
macro:->We
observe,
without
much
enthusiasm,
that
there
is
no
particular
constraint
on
the
order
in
which
the
ports
are
closed,
so
they
could
be
closed
in
parallel
by
the
more
complicated:
\par
\textsc
{(||
(for
(out<-outs)
yield
proc
{
out.closeOut
})
||
in.closeIn)()}
\par

\@endanenote 
\@doanenote {16}
macro:->Although
it
is
incidental
to
the
theme
of
this
example,
it
is
worth
noticing
that
we
construct
the
concurrent
process
\textsc
{broadcast}
before
starting
the
iteration.
While
this
is
not
strictly
necessary,
it
provides
an
improvement
in
efficiency
over:
\textsc
{repeat
\{
in
?
\{
d
=>
\{||
(for
(out<-outs)
yield
proc
\{
out!d
\})()
\}\}\}}.
This
is
because
the
expression:
\textsc
{||(for
(out<-outs)}
...
\textsc
{)}
that
constructs
the
concurrent
broadcast
process
is
evaluated
only
once,
rather
than
being
evaluated
once
per
broadcast.
\@endanenote 
\@doanenote {17}
macro:->Guard
expressions
must
be
free
of
side-effects,
and
a
$(guard)$
that
is
literally
\textsf
{(true)}
may
be
omitted.

\@endanenote 
\@doanenote {18}
macro:->We
say
``in
principle''
because
we
wish
to
retain
the
freedom
to
use
a
much
more
efficient
implementation
than
is
described
here,
namely
an
adaptation
of
that
described
in
\cite
{BGJK}.
\@endanenote 
\@doanenote {19}
macro:->An
early
version
of
CSO
provided
an
even
more
general
form,
in
which
the
epilogue
was
a
function,
and
the
value
of
the
expression
was
passed
to
this
function
once
it
had
been
transmitted.
This
proved
incompatible
with
the
Scala
type
system.
\@endanenote 
\@doanenote {20}
macro:->The
operator
$\Longrightarrow
$
that
introduces
the
{epilogue}
is
pronounced
``and
then''.
\@endanenote 
\@doanenote {21}
macro:->It
is
perhaps
worthwhile
comparing
this
construction
with
that
of
the
analogous
JCSP
component
shown
in
\Listing
\ref
{javafairplex}
(page
\pageref
{javafairplex}).
\@endanenote 
\@doanenote {22}
macro:->The
implementation
of
this
feature
employs
a
nonzero
timeout
for
the
wait
in
phase
2,
and
is
not
subject
to
any
potential
race
conditions.
\@endanenote 
\@doanenote {23}
macro:->Nanosecond
is
now
the
unit
of
resolution
of
CSO
time.
It's
not
yet
realistic
to
measure
delays
or
timeouts
in
small
numbers
of
nanoseconds,
so
appropriate
multipliers,
such
as
\textsc
{microSec,
milliSec,
Sec,
Min,
Hour,
Day}
are
provided
as
part
of
the
CSO
package.
\@endanenote 
\@doanenote {24}
macro:->Gavin
Lowe
\cite
{lowe}
worked
with
an
earlier
version
of
CSO
to
remove
this
restriction.

\@endanenote 
\@doanenote {25}
macro:->This
difficulty
is
analogous
to
the
well-known
difficulty
in
Java
caused
by
the
covariance
of
the
array
constructor.
\@endanenote 
\@doanenote {26}
macro:->The
main
distributed
Scala
implementation
translates
directly
into
the
JVM;
though
another
compiler
translates
into
the
\texttt
{.net}
CLR.
The
existence
of
the
latter
compiler
encouraged
us
to
build
a
pure
Scala
CSO
library
rather
than
simply
providing
wrappers
for
the
longer-established
JCSP
library.
\@endanenote 
\@doanenote {27}
macro:->In
some
contexts
fuller
type
information
has
to
be
given,
as
in:
\textsc
{\{
case
bv:
T
=>
body
\}}.
Functions
may
also
be
defined
by
cases
over
free
types;
for
an
example
see
the
match
expression
within
\textsc
{receiver}
in
section
\ref
{Timed
Alternation}
\@endanenote 
